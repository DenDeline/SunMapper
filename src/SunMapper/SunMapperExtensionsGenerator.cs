using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SunMapper
{
    [Generator]
    public class SunMapperExtensionsGenerator : ISourceGenerator
    {
        private const string MapperExtensionsStub = @"
// <auto-generated/ >
namespace SunMapper.Generated.Extensions
{
    public static class MapperExtensions
    {

    }
}
";
        
        private const string MapperAttributesNamespace = "SunMapper.Common.Attributes";

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not SyntaxReceiver syntaxReceiver)
            {
                return;
            }
            
            var classesToMap = GetMapClassesInfo(context.Compilation, syntaxReceiver.CandidateClasses).ToArray();

            if (classesToMap.Any())
            {
                var sb = new StringBuilder();
                GenerateMapperExtensions(context, sb, classesToMap);
                context.AddSource("SunMapperGenerated", SourceText.From(sb.ToString(), Encoding.UTF8));
            }
            else
            {
                context.AddSource("SunMapperGenerated", SourceText.From(MapperExtensionsStub, Encoding.UTF8));
            }
        }
        
        private void GenerateMapperExtensions(GeneratorExecutionContext context, StringBuilder sb, IEnumerable<MapperInfo> infos)
        {
            const string indent = "    ";
            
            sb.AppendLine(@"
// <auto-generated/ >
namespace SunMapper.Generated.Extensions
{
    public static class MapperExtensions
    {");

            foreach (var info in infos)
            {
                GenerateExtensionMethod(context, sb, info, indent + indent);
                sb.AppendLine();
            }
            sb.AppendLine(@"
    }
}");
        }

        private void GenerateExtensionMethod(GeneratorExecutionContext context, StringBuilder sb, MapperInfo info, string indent)
        {
            // TODO: 
            if (info.Destination.DeclaredAccessibility != Accessibility.Public ||
                info.Source.DeclaredAccessibility != Accessibility.Public)
            {
                return;
            }

            sb.AppendLine($"{indent}public static bool TryMapTo(this {info.Source} source, out {info.Destination} destination)");
            sb.AppendLine($"{indent}{{ ");
                
            GenerateExtensionMethodBody(context, sb, info, indent + indent);

            sb.AppendLine($"{indent}}}");
        }

        private void GenerateExtensionMethodBody(GeneratorExecutionContext context, StringBuilder sb, MapperInfo info, string indent)
        {
            sb.AppendLine($"{indent} destination = new(); return true; ");
        }
        
        private static IEnumerable<MapperInfo> GetMapClassesInfo(
            Compilation compilation, 
            IEnumerable<ClassInfo> candidateClassesInfo)
        {
            INamedTypeSymbol? searchingAttributeType = compilation.GetTypeByMetadataName($"{MapperAttributesNamespace}.MapToAttribute");

            if (searchingAttributeType is null)
            {
                throw new NullReferenceException("MapToAttribute hasn't declared.");
            }
            
            foreach (var candidateClassInfo in candidateClassesInfo)
            {
                ClassDeclarationSyntax candidateClass = candidateClassInfo.ClassDeclaration;
                SemanticModel model = compilation.GetSemanticModel(candidateClass.SyntaxTree);
                
                IEnumerable<AttributeSyntax> candidateClassAttributes = candidateClassInfo.Attributes;
                
                var searchedAttributes =  candidateClassAttributes
                    .Where(_ => model.GetTypeInfo(_).Type?.Equals(searchingAttributeType, SymbolEqualityComparer.Default) ?? false)
                    .ToArray();

                if (!searchedAttributes.Any())
                {
                    continue;
                }
                
                ITypeSymbol? sourceClassType = model.GetDeclaredSymbol(candidateClass);
                
                if (sourceClassType is null)
                {
                    throw new NullReferenceException("MapToAttribute hasn't declared.");
                }
                
                foreach (var searchedAttribute in searchedAttributes)
                {
                    TypeOfExpressionSyntax? typeOfExpression = searchedAttribute
                        .ArgumentList?.Arguments.First().Expression as TypeOfExpressionSyntax;
                    if (typeOfExpression is null)
                    {
                        continue;
                    }
                    
                    TypeSyntax? destinationResouraseType = typeOfExpression.Type;

                    if(destinationResouraseType is null){
                        throw new NullReferenceException();
                    }

                    ITypeSymbol? destinationClassType = model.GetTypeInfo(destinationResouraseType).Type;
                    if (destinationClassType is null)
                    {
                        throw new NullReferenceException();
                    }

                    yield return new MapperInfo(sourceClassType, destinationClassType);
                }
                    
            }
        }
    }
}