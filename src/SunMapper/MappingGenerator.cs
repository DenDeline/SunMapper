using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SunMapper
{
    [Generator]
    public class MappingGenerator : ISourceGenerator
    {
        private const string GlobalIndent = "\t";
        
        private const string MapperExtensionsStub = @"
// <auto-generated/ >
namespace SunMapper.Generated.Extensions
{
    public static class SunMapperExtensions
    {

    }
}
";
        
        private const string MapperAttributesNamespace = "SunMapper.Common.Attributes";

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not SyntaxReceiver syntaxReceiver)
            {
                return;
            }
            
            GenerateMapperExtensions(context, syntaxReceiver);
        }
        
        private void GenerateMapperExtensions(GeneratorExecutionContext context, SyntaxReceiver syntaxReceiver)
        {
            string indent = GlobalIndent;
            
            var classesToMap = GetMapClassesInfo(context.Compilation, syntaxReceiver.CandidateClasses).ToArray();
            
            if (!classesToMap.Any())
            {
                context.AddSource("SunMapperGenerated", SourceText.From(MapperExtensionsStub, Encoding.UTF8));
                return;
                
            }
            
            var sb = new StringBuilder();
            
            
            sb.AppendLine(@"
// <auto-generated/ >
namespace SunMapper.Generated.Extensions
{
    public static class SunMapperExtensions
    {");

            foreach (var classToMap in classesToMap)
            {
                GenerateExtensionMethod(context, sb, classToMap, indent + GlobalIndent);
                
                sb.AppendLine();
            }
            sb.AppendLine(@"
    }
}");
            
            context.AddSource("SunMapperGenerated", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
        

        private void GenerateExtensionMethod(GeneratorExecutionContext context, StringBuilder sb, MappingClassesInfo info, string indent)
        {
            // TODO: 
            if (info.Destination.DeclaredAccessibility != Accessibility.Public ||
                info.Source.DeclaredAccessibility != Accessibility.Public)
            {
                return;
            }

            sb.AppendLine($"{indent}public static bool TryMapTo(this {info.Source} source, out {info.Destination} destination)");
            sb.AppendLine($"{indent}{{ ");
                
            GenerateExtensionMethodBody(context, sb, info, indent + GlobalIndent);

            sb.AppendLine($"{indent}}}");
        }

        private void GenerateExtensionMethodBody(GeneratorExecutionContext context, StringBuilder sb, MappingClassesInfo info, string indent)
        {
            sb.AppendLine($"{indent}try {{");
            sb.AppendLine($"{indent}{GlobalIndent}destination = new()");
            sb.AppendLine($"{indent}{GlobalIndent}{{");
            
            var destinationClassProperties = info.Destination.GetMembers().OfType<IPropertySymbol>().ToArray();
            var sourceClassProperties = info.Source.GetMembers().OfType<IPropertySymbol>().ToArray();

            
            foreach (var destinationClassProperty in destinationClassProperties)
            {
                if (sourceClassProperties.Any(_ =>  
                    _.Name == destinationClassProperty.Name &&  
                    _.Type.Equals(destinationClassProperty.Type, SymbolEqualityComparer.Default)))
                {
                    sb.AppendLine($"{indent}{GlobalIndent}{GlobalIndent}{destinationClassProperty.Name} = source.{destinationClassProperty.Name},");
                }
            }
            sb.AppendLine($"{indent}{GlobalIndent}}};");
            sb.AppendLine();
            sb.AppendLine($"{indent}{GlobalIndent}return true;");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine($"{indent}catch (System.Exception) {{");
            sb.AppendLine($"{indent}{GlobalIndent}destination = null;");
            sb.AppendLine();
            sb.AppendLine($"{indent}{GlobalIndent}return false;");
            sb.AppendLine($"{indent}}};");
        }
        
        private static IEnumerable<MappingClassesInfo> GetMapClassesInfo(
            Compilation compilation, 
            IEnumerable<ClassSourceTreeInfo> candidateClassesInfo)
        {
            INamedTypeSymbol? searchingAttributeType = compilation.GetTypeByMetadataName($"{MapperAttributesNamespace}.MapToAttribute");

            if (searchingAttributeType is null)
            {
                throw new NullReferenceException("MapToAttribute hasn't declared.");
            }
            
            foreach (var candidateClassInfo in candidateClassesInfo)
            {
                ClassDeclarationSyntax candidateClass = candidateClassInfo.Declaration;
                SemanticModel model = compilation.GetSemanticModel(candidateClass.SyntaxTree);
                
                IEnumerable<AttributeSyntax> candidateClassAttributes = candidateClassInfo.Attributes;
                
                var searchedAttributes =  candidateClassAttributes
                    .Where(_ => model.GetTypeInfo(_).Type?.Equals(searchingAttributeType, SymbolEqualityComparer.Default) ?? false)
                    .ToArray();

                if (!searchedAttributes.Any())
                {
                    continue;
                }
                
                INamedTypeSymbol? sourceClassType = model.GetDeclaredSymbol(candidateClass);

                if (sourceClassType is null)
                {
                    throw new NullReferenceException("MapToAttribute hasn't declared.");
                }
                
                foreach (var searchedAttribute in searchedAttributes)
                {
                    TypeOfExpressionSyntax? typeOfExpression = searchedAttribute
                        .ArgumentList?.Arguments.First().Expression as TypeOfExpressionSyntax;
                    if (typeOfExpression is null)
                    {
                        continue;
                    }
                    
                    TypeSyntax? destinationResourceType = typeOfExpression.Type;

                    if(destinationResourceType is null)
                    {
                        throw new NullReferenceException();
                    }
                    

                    if (model.GetTypeInfo(destinationResourceType).Type is not INamedTypeSymbol destinationClassType)
                    {
                        throw new NullReferenceException();
                    }

                    yield return new MappingClassesInfo(sourceClassType, destinationClassType);
                }
                    
            }
        }
    }
}