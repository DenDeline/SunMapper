using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace SunMapper
{
    [Generator]
    public class MappingGenerator : ISourceGenerator
    {
        
        private const string MapperExtensionsStub = @"
// <auto-generated/ >
namespace SunMapper.Generated
{
    
}
";

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not SyntaxReceiver syntaxReceiver)
            {
                return;
            }
            
            SourceCodeManager codeManager = new(syntaxReceiver);
            var mappingClasses = codeManager.GetMappingClassesByMapToAttribute(context.Compilation);
            GenerateMapperExtensions(context, mappingClasses);
        }
        
        private void GenerateMapperExtensions(GeneratorExecutionContext context, IDictionary<INamedTypeSymbol, ISet<INamedTypeSymbol>> classesToMap)
        {
            if (classesToMap.Count == 0)
            {
                context.AddSource("StubExtension", SourceText.From(MapperExtensionsStub, Encoding.UTF8));
                return;
            }
            
            foreach (var classToMap in classesToMap)
            {
                var source = classToMap.Key;
                var destinations = classToMap.Value;
                
                var sb = new StringBuilder();

                sb.Append(@$"
// <auto-generated/ >
namespace SunMapper.Generated
{{
    public static class {source.Name}GeneratedExtensions 
    {{");

                foreach (var destination in destinations)
                {

                    sb.Append(@$"

        public static bool TryMapTo(this {source} source, out {destination} destination)
        {{
            try {{
                destination = new() 
                {{");
                    
                    var destinationClassProperties = destination.GetMembers().OfType<IPropertySymbol>().ToArray();
                    var sourceClassProperties = source.GetMembers().OfType<IPropertySymbol>().ToArray();
            
                    foreach (var destinationClassProperty in destinationClassProperties)
                    {
                        if (sourceClassProperties.Any(_ =>  
                            _.Name == destinationClassProperty.Name &&  
                            _.Type.Equals(destinationClassProperty.Type, SymbolEqualityComparer.Default)))
                        {
                            
                            sb.Append($@"
                    {destinationClassProperty.Name} = source.{destinationClassProperty.Name},");
                            
                        }
                    }

                    sb.Append($@"
                }};

                return true;
            }}
            catch(System.Exception) {{
                destination = null;
                
                return false;
            }} 
        }}");
                }
                
                sb.AppendLine(@$"    
    }}
}}");
                
                context.AddSource(source.Name + "GeneratedExtensions", SourceText.From(sb.ToString(), Encoding.UTF8));
            }
        }
    }
}