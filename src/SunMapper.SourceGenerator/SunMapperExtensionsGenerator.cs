using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SunMapper.SourceGenerator
{
    [Generator]
    public class SunMapperExtensionsGenerator : ISourceGenerator
    {
        private const string MapperExtensionsStub = @"
// <auto-generated/ >
namespace SunMapperExtensions
{
    public static class MapperExtensions
    {

    }
}
";
        
        private const string MapperAttributesNamespace = "SunMapper.Attributes";

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not SyntaxReceiver syntaxReceiver)
            {
                return;
            }
            
            var classDeclarations = syntaxReceiver.CandidateClasses;

            var classesToMap = GetMapClassesInfo(context.Compilation, classDeclarations);

            if (classesToMap.Any())
            {
                var sb = new StringBuilder();
                GenerateMapperExtensions(context, sb, classesToMap);
                context.AddSource("SunMapperGenerated", SourceText.From(sb.ToString(), Encoding.UTF8));
            }
            else
            {
                context.AddSource("SunMapperGenerated", SourceText.From(MapperExtensionsStub, Encoding.UTF8));
            }
        }
        
        private void GenerateMapperExtensions(GeneratorExecutionContext context, StringBuilder sb, IEnumerable<MapperInfo> infos)
        {
            const string indent = "    ";
            
            sb.AppendLine(@"
// <auto-generated/ >
namespace SunMapperExtensions
{
    public static class MapperExtensions
    {");

            foreach (var info in infos)
            {
                GenerateExtensionMethod(context, sb, info, indent + indent);
                sb.AppendLine();
            }
            sb.AppendLine(@"
    }
}");
        }

        private void GenerateExtensionMethod(GeneratorExecutionContext context, StringBuilder sb, MapperInfo info, string indent)
        {
            // TODO: 
            if (info.Destination.DeclaredAccessibility != Accessibility.Public ||
                info.Source.DeclaredAccessibility != Accessibility.Public)
            {
                return;
            }

            sb.AppendLine($"{indent}public static bool TryMapTo(this {info.Source} source, out {info.Destination} destination)");
            sb.AppendLine($"{indent}{{ ");
                
            GenerateExtensionMethodBody(context, sb, info, indent + indent);

            sb.AppendLine($"{indent}}}");
        }

        private void GenerateExtensionMethodBody(GeneratorExecutionContext context, StringBuilder sb, MapperInfo info, string indent)
        {
            sb.AppendLine($"{indent} destination = new(); return true; ");
        }
        
        private static IEnumerable<MapperInfo> GetMapClassesInfo(
            Compilation compilation, 
            IEnumerable<ClassDeclarationSyntax> classDeclarations)
        {
            foreach (var classDeclaration in classDeclarations)
            {
                SemanticModel model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                
                ITypeSymbol? sourceClassType = model.GetDeclaredSymbol(classDeclaration);
                INamedTypeSymbol? attributeSymbol = compilation.GetTypeByMetadataName($"{MapperAttributesNamespace}.MapToAttribute");
                
                if (sourceClassType is null ||
                    attributeSymbol is null)
                {
                    continue;
                }

                var classAttrubuteSymbols = sourceClassType.GetAttributes();

                if (!classAttrubuteSymbols.Any(_ => _.AttributeClass!.Equals(attributeSymbol, SymbolEqualityComparer.Default)))
                {
                    continue;
                };

                var attributeDeclarations = GetAttributesByName(classDeclaration, "MapTo");

                foreach (var attributeDeclaration in attributeDeclarations)
                {
                    var typeOfExpression = attributeDeclaration.ArgumentList?.Arguments.First().Expression as TypeOfExpressionSyntax;

                    if (typeOfExpression is null)
                    {
                        continue;
                    }
                    var destinationResouraseType = typeOfExpression.Type;

                    if(destinationResouraseType is null){
                        throw new NullReferenceException();
                    }

                    ITypeSymbol? destination = model.GetTypeInfo(destinationResouraseType).Type;

                    if (destination is null)
                    {
                        throw new NullReferenceException();
                    }

                    yield return new MapperInfo(sourceClassType, destination);
                }
                    
            }
            
            static IEnumerable<AttributeSyntax> GetAttributesByName(ClassDeclarationSyntax classDeclaration, string attributeName)
            {
                foreach (var attributeList in classDeclaration.AttributeLists)
                {
                    foreach (var attribute in attributeList.Attributes)
                    {
                        if (attribute.Name.ToString() == attributeName)
                        {
                            yield return attribute;
                        }
                    }
                }
            }
        }
    }
}